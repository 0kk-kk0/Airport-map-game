<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Game Challenge</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet.js for interactive maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Google Fonts: Inter & Roboto Mono -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">

    <!-- KaTeX for beautiful math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0KOVEMckDpbRei4iuOorsMa2xz/bCaVXSwnsoDhevrVoQfxn6MVqd" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlVwcjNcsNQpWgfdTAnMGTNXEhsRRCggSFrFXgNmjS2JkGx8o7gKjV2jHrv" crossorigin="anonymous"></script>

    <style>
        body { font-family: 'Inter', sans-serif; touch-action: manipulation; }
        .screen-overlay { position: absolute; inset: 0; background-color: rgba(26, 32, 44, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: white; padding: 2rem; z-index: 30; }
        
        /* --- Airport Game Specific Styles --- */
        #map { height: 100vh; width: 100vw; z-index: 10; background-color: #a2d1f7; }
        .correct-answer-icon { background-color: #4f008c; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .user-guess-icon { background-color: #f5a623; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .mastery-star { color: #FFD700; text-shadow: 0 0 2px black; }
        .mastery-star-empty { color: #a0a0a0; }
        .leaflet-popup-content-wrapper { background-color: #2d3748; color: white; border-radius: 8px; }
        .leaflet-popup-content { margin: 13px 19px; line-height: 1.4; }
        .leaflet-popup-tip { background: #2d3748; }
        .leaflet-marker-icon.practice-marker { background-color: rgba(79, 0, 140, 0.7); border: 2px solid white; border-radius: 50%; }

        /* --- Approximation Quiz Specific Styles --- */
        #approx-game-container { font-family: 'Inter', sans-serif; background-color: #1a202c; color: #e2e8f0;}
        .approx-option { transition: background-color 0.2s, transform 0.2s; }
        .approx-option:hover { background-color: #4a5568; transform: translateY(-2px); }
        .correct-option { background-color: #2f855a !important; color: white; }
        .incorrect-option { background-color: #c53030 !important; color: white; }
        .katex-display { font-size: 2.25rem; }

        /* --- 3D Cube Puzzle Styles --- */
        #cube-game-container { background-color: #111827; color: #f3f4f6; }
        .cube-viewer { cursor: grab; background-color: #1f2937; border-radius: 0.5rem; }
        .challenge-mode .cube-viewer { cursor: default; }
        .cube-choice-card { transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s; }
        .cube-choice-card:hover { border-color: #3b82f6; transform: translateY(-4px); }
        .selected-choice { border-color: #3b82f6; box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
    </style>
</head>
<body class="bg-gray-800 overflow-hidden">

    <div id="game-container" class="relative w-screen h-screen">
        <!-- Shared Elements -->
        <div id="loading-screen" class="screen-overlay"><h1 class="text-4xl font-bold">Connecting...</h1></div>
        <div id="confirm-modal" class="screen-overlay hidden bg-black/80">
             <div class="bg-white text-black p-8 rounded-lg shadow-xl max-w-sm text-center">
                 <h2 id="confirm-title" class="text-2xl font-bold mb-4">Reset Progress?</h2>
                 <p id="confirm-text" class="mb-6">Are you sure?</p>
                 <div class="flex justify-center gap-4">
                     <button id="confirm-yes-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg">Yes</button>
                     <button id="confirm-no-button" class="bg-gray-300 hover:bg-gray-400 text-black font-bold py-2 px-6 rounded-lg">Cancel</button>
                 </div>
             </div>
        </div>

        <!-- Home Screen (Game Selector) -->
        <div id="home-screen" class="screen-overlay hidden">
            <h1 class="text-4xl md:text-6xl font-extrabold mb-4 text-purple-300">Game Challenge</h1>
            <p class="text-lg md:text-xl mb-8 max-w-2xl">Select a game to begin.</p>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 max-w-6xl w-full">
                <!-- Selectors -->
                <div id="select-airport-game" class="cursor-pointer bg-gray-900/50 p-6 rounded-lg border-2 border-transparent hover:border-purple-500 transition-all">
                    <h2 class="text-3xl font-bold mb-2 text-purple-400">Airport Challenge</h2>
                    <p class="text-gray-300">Find Thai Airways destinations on an interactive map.</p>
                </div>
                <div id="select-approx-game" class="cursor-pointer bg-gray-900/50 p-6 rounded-lg border-2 border-transparent hover:border-teal-500 transition-all">
                    <h2 class="text-3xl font-bold mb-2 text-teal-400">Approximation Quiz</h2>
                    <p class="text-gray-300">Test your mental math skills with rapid-fire problems.</p>
                </div>
                <div id="select-cube-game" class="cursor-pointer bg-gray-900/50 p-6 rounded-lg border-2 border-transparent hover:border-blue-500 transition-all">
                    <h2 class="text-3xl font-bold mb-2 text-blue-400">3D Cube Puzzle</h2>
                    <p class="text-gray-300">Visualize and assemble a 3x3x3 cube from its parts.</p>
                </div>
            </div>
             <div class="mt-8 text-xs bg-black/30 p-2 rounded-lg">User ID: <span id="user-id-display"></span></div>
        </div>
        
        <!-- Airport Geography Game -->
        <div id="airport-game-container" class="hidden">
            <div id="map"></div>
            <div id="airport-home-screen" class="screen-overlay">
                 <h1 class="text-4xl md:text-6xl font-extrabold mb-4 text-purple-300">Airport Challenge</h1>
                 <div id="progress-summary" class="mb-4 text-lg bg-black/30 p-4 rounded-lg">
                     <p>Mastered: <span id="mastered-count">0</span> / 64</p>
                 </div>
                 <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                     <button data-mode="practice" class="mode-select-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl shadow-lg">Practice</button>
                     <button data-mode="guessLocationName" class="mode-select-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-xl shadow-lg">Guess by Name</button>
                     <button data-mode="guessLocationCode" class="mode-select-button bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-6 rounded-lg text-xl shadow-lg">Guess by Code</button>
                 </div>
                 <button id="back-to-main-menu-airport" class="mt-8 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Back to Main Menu</button>
            </div>
            <div id="airport-game-ui" class="absolute top-0 left-0 w-full p-4 md:p-6 z-20 hidden pointer-events-none">
                <div class="max-w-7xl mx-auto flex justify-between items-center bg-white/80 backdrop-blur-sm p-4 rounded-xl shadow-lg pointer-events-auto">
                    <button id="back-to-airport-home" class="bg-gray-400 hover:bg-gray-500 text-white font-bold p-2 rounded-full mr-4">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1V10a1 1 0 00-1-1H7a1 1 0 00-1 1v10a1 1 0 001 1h2z" /></svg>
                    </button>
                    <div class="flex-1">
                        <p class="text-sm font-medium text-gray-500">Find this destination:</p>
                        <div class="flex items-center gap-2">
                             <h2 id="destination-prompt" class="text-xl md:text-3xl font-bold text-purple-800"></h2>
                             <span id="mastery-display" class="text-xl md:text-2xl"></span>
                        </div>
                    </div>
                    <div class="text-right ml-4"><p class="text-sm text-gray-500">Question</p><p id="question-counter" class="text-xl md:text-3xl font-bold text-gray-700"></p></div>
                    <div class="text-right ml-4 border-l pl-4"><p class="text-sm text-gray-500">Score</p><p id="score-counter" class="text-2xl md:text-3xl font-bold text-green-600">0</p></div>
                </div>
            </div>
            <div id="airport-feedback-box" class="absolute bottom-0 left-0 w-full p-4 md:p-6 z-20 hidden pointer-events-none">
                 <div class="max-w-md mx-auto bg-white p-6 rounded-xl shadow-2xl text-center pointer-events-auto">
                     <p id="feedback-text" class="text-xl font-semibold mb-4"></p>
                     <p id="feedback-details" class="text-gray-600 mb-4"></p>
                     <button id="next-button" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-lg">Next</button>
                 </div>
            </div>
            <div id="airport-end-screen" class="screen-overlay hidden">
                 <h1 class="text-4xl md:text-6xl font-extrabold mb-4 text-purple-300">Quiz Complete!</h1>
                 <p class="text-lg md:text-xl mb-4">Final Score:</p>
                 <p id="final-score" class="text-7xl font-bold mb-8 text-green-400"></p>
                 <div class="flex flex-col sm:flex-row gap-4">
                     <button id="restart-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg text-xl">Play Again</button>
                     <button id="airport-home-from-end" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg text-xl">Home</button>
                     <button id="reset-progress-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-lg text-xl">Reset Progress</button>
                 </div>
            </div>
        </div>

        <!-- Approximation Math Game -->
        <div id="approx-game-container" class="w-full h-full flex-col justify-center items-center p-8 hidden">
             <!-- Approximation Mode Selection -->
            <div id="approx-home-screen" class="screen-overlay">
                 <h1 class="text-4xl md:text-6xl font-extrabold mb-4 text-teal-300">Approximation Quiz</h1>
                 <p class="text-lg md:text-xl mb-8 max-w-2xl">Choose your challenge.</p>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                     <button id="approx-practice-mode-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-lg text-xl shadow-lg">Practice Mode</button>
                     <button id="approx-test-mode-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-4 px-8 rounded-lg text-xl shadow-lg">Test Mode</button>
                 </div>
                 <button id="back-to-main-menu-approx" class="mt-8 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Back to Main Menu</button>
            </div>

             <div id="approx-game-ui" class="w-full max-w-4xl mx-auto hidden">
                <!-- Header -->
                <div class="flex justify-between items-center mb-6">
                    <div class="flex items-center gap-4">
                        <button id="approx-back-to-home-ingame" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Home</button>
                        <div>
                            <div id="approx-mode-display" class="text-xl font-bold text-white"></div>
                            <div id="approx-question-counter" class="text-sm text-gray-400"></div>
                        </div>
                    </div>
                    <div class="text-right">
                        <div id="approx-timer-label" class="text-sm text-gray-400">TIME</div>
                        <div id="approx-timer" class="text-3xl font-bold text-teal-400"></div>
                    </div>
                </div>
                
                <!-- Game Content -->
                <div id="approx-content">
                    <div class="bg-gray-900/50 p-8 rounded-lg text-center mb-6 min-h-[150px] flex justify-center items-center">
                        <h2 id="approx-question" class="text-white"></h2>
                    </div>
                    <div id="approx-options" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
                </div>
                
                <!-- Feedback/Answer Key (Practice Mode Only) -->
                <div id="approx-feedback" class="hidden mt-6 bg-gray-900/50 p-6 rounded-lg">
                     <h3 id="feedback-title" class="text-2xl font-bold mb-3"></h3>
                     <div id="answer-key" class="text-left">
                         <p class="font-semibold text-teal-300">The Trick (How to Estimate):</p>
                         <p id="answer-key-trick" class="font-mono bg-black/30 p-3 rounded-md"></p>
                         <p class="mt-2 text-gray-400">The exact answer is <b id="exact-answer" class="text-white"></b>.</p>
                     </div>
                     <button id="approx-next-btn" class="w-full mt-4 bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 rounded-lg text-lg">Next Question</button>
                </div>
             </div>

             <!-- End Screen for Approx Game -->
            <div id="approx-end-screen" class="screen-overlay hidden">
                 <h1 class="text-4xl md:text-6xl font-extrabold mb-4 text-teal-300">Quiz Over!</h1>
                 <p class="text-lg md:text-xl mb-4">Your Final Score:</p>
                 <p id="approx-final-score" class="text-7xl font-bold mb-8 text-teal-400"></p>
                 <div class="flex gap-4">
                     <button id="approx-restart-button" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-8 rounded-lg text-xl">Play Again</button>
                     <button id="approx-home-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg text-xl">Main Menu</button>
                 </div>
            </div>
        </div>

        <!-- 3D Cube Puzzle Game -->
        <div id="cube-game-container" class="w-full h-full flex-col hidden overflow-hidden">
            <div id="cube-home-screen" class="screen-overlay">
                <h1 class="text-4xl md:text-6xl font-extrabold mb-4 text-blue-300">3D Cube Puzzle</h1>
                <p class="text-lg md:text-xl mb-8 max-w-2xl">Choose your challenge level.</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <button id="cube-standard-mode-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-lg text-xl shadow-lg">Standard Mode</button>
                    <button id="cube-challenge-mode-btn" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-4 px-8 rounded-lg text-xl shadow-lg">Challenge Mode</button>
                </div>
                <button id="cube-back-to-main-menu-from-home" class="mt-8 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Back to Main Menu</button>
            </div>

            <div id="cube-game-ui" class="w-full h-full flex-col p-4 md:p-6 overflow-y-auto hidden">
                <header class="text-center mb-4">
                    <div class="flex items-center justify-between relative mb-2 w-full max-w-5xl mx-auto">
                        <button id="cube-back-to-home" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Modes</button>
                        <div class="text-center">
                           <h1 id="cube-problem-counter" class="text-2xl font-bold text-blue-300">Problem 1 / 15</h1>
                        </div>
                        <div id="cube-timer" class="text-2xl font-bold text-yellow-400 bg-gray-900/50 px-4 py-2 rounded-lg">07:00</div>
                    </div>
                    <p class="text-gray-400 max-w-3xl mx-auto text-sm md:text-base">Assemble the cube by choosing the correct missing part.</p>
                </header>

                <main class="flex-grow flex flex-col items-center">
                    <div class="w-full flex flex-col md:flex-row justify-center items-center gap-4 md:gap-8 mb-4">
                        <div class="text-center">
                            <h2 class="text-lg font-bold mb-2">Given Part 1 (White)</h2>
                            <canvas id="cube-viewer-part1" class="viewer cube-viewer w-[280px] h-[280px] md:w-[320px] md:h-[320px]"></canvas>
                        </div>
                        <div class="text-center">
                            <h2 class="text-lg font-bold mb-2">Given Part 2 (Red)</h2>
                            <canvas id="cube-viewer-part2" class="viewer cube-viewer w-[280px] h-[280px] md:w-[320px] md:h-[320px]"></canvas>
                        </div>
                    </div>

                    <h2 class="text-lg font-bold my-2">Select the missing part (Green):</h2>
                    <div id="cube-choices-container" class="w-full max-w-5xl grid grid-cols-2 md:grid-cols-4 gap-4"></div>
                    
                    <div id="cube-navigation" class="w-full max-w-5xl mt-6 flex justify-between">
                        <button id="cube-prev-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed">Previous</button>
                        <button id="cube-next-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg">Next</button>
                    </div>
                </main>
            </div>
            
            <div id="cube-end-screen" class="screen-overlay hidden">
                <div class="bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-7xl h-[90vh] flex flex-col">
                    <div class="text-center mb-4">
                        <h1 class="text-5xl font-extrabold text-blue-300">Test Complete!</h1>
                        <p class="text-3xl font-bold mt-2">Final Score: <span id="cube-final-score" class="text-green-400"></span></p>
                    </div>
                    <div id="answer-key-container" class="flex-grow bg-gray-900/50 rounded-lg p-4 overflow-y-auto">
                        <!-- Answer key will be generated here -->
                    </div>
                    <div class="mt-6 flex justify-center gap-4">
                        <button id="cube-restart-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">Play Again</button>
                        <button id="cube-end-home-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg">Game Modes</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- SHARED STATE & DOM ---
        const loadingScreen = document.getElementById('loading-screen');
        const homeScreen = document.getElementById('home-screen');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmYesButton = document.getElementById('confirm-yes-button');
        const confirmNoButton = document.getElementById('confirm-no-button');
        const userIdDisplay = document.getElementById('user-id-display');

        let auth, db, app, userId;
        let onConfirmAction = null;
        let isInitialLoad = true;
        
        // --- Game Containers ---
        const airportGameContainer = document.getElementById('airport-game-container');
        const approxGameContainer = document.getElementById('approx-game-container');
        const cubeGameContainer = document.getElementById('cube-game-container');
        
        // --- Game Selectors ---
        const selectAirportGame = document.getElementById('select-airport-game');
        const selectApproxGame = document.getElementById('select-approx-game');
        const selectCubeGame = document.getElementById('select-cube-game');

        // =================================================================
        // ::: APPROXIMATION QUIZ LOGIC :::
        // =================================================================
        const approxDOM = {
            container: document.getElementById('approx-game-container'),
            homeScreen: document.getElementById('approx-home-screen'),
            gameUI: document.getElementById('approx-game-ui'),
            practiceModeBtn: document.getElementById('approx-practice-mode-btn'),
            testModeBtn: document.getElementById('approx-test-mode-btn'),
            content: document.getElementById('approx-content'),
            question: document.getElementById('approx-question'),
            options: document.getElementById('approx-options'),
            modeDisplay: document.getElementById('approx-mode-display'),
            questionCounter: document.getElementById('approx-question-counter'),
            timer: document.getElementById('approx-timer'),
            timerLabel: document.getElementById('approx-timer-label'),
            feedback: document.getElementById('approx-feedback'),
            feedbackTitle: document.getElementById('feedback-title'),
            answerKeyTrick: document.getElementById('answer-key-trick'),
            exactAnswer: document.getElementById('exact-answer'),
            nextBtn: document.getElementById('approx-next-btn'),
            endScreen: document.getElementById('approx-end-screen'),
            finalScore: document.getElementById('approx-final-score'),
            restartBtn: document.getElementById('approx-restart-button'),
            homeBtn: document.getElementById('approx-home-button'),
            backToMenuBtn: document.getElementById('back-to-main-menu-approx'),
            ingameHomeBtn: document.getElementById('approx-back-to-home-ingame'),
        };

        const approxState = {
            questions: [], currentQIndex: 0, correctAnswers: 0,
            timer: null, timeLeft: 0, activeMode: 'practice',
        };

        const approxQuestions = [
            { latex: "\\frac{2.35 \\times 4.27}{3.67} \\times 3.56", answer: 9.74, trick: "\\frac{2.5 \\times 4}{3.5} \\times 3.5 \\approx 10" },
            { latex: "\\frac{8.12 \\times 1.95}{4.09} \\times 2.41", answer: 9.33, trick: "\\frac{8 \\times 2}{4} \\times 2.5 = 4 \\times 2.5 = 10" },
            { latex: "\\frac{5.78 \\times 6.02}{2.11} \\times 1.15", answer: 18.96, trick: "\\frac{6 \\times 6}{2} \\times 1 = 18" },
            { latex: "\\frac{3.45 \\times 7.89}{1.23} \\times 0.98", answer: 21.69, trick: "\\frac{3.5 \\times 8}{1.25} \\times 1 \\approx 28 / 1.25 \\approx 22" },
            { latex: "\\frac{9.63 \\times 2.05}{5.55} \\times 4.72", answer: 16.79, trick: "\\frac{10 \\times 2}{5} \\times 4.5 = 4 \\times 4.5 = 18" },
            { latex: "\\frac{6.14 \\times 3.81}{2.92} \\times 1.55", answer: 12.42, trick: "\\frac{6 \\times 4}{3} \\times 1.5 = 8 \\times 1.5 = 12" },
            { latex: "\\frac{4.09 \\times 5.22}{1.76} \\times 0.89", answer: 10.80, trick: "\\frac{4 \\times 5}{2} \\times 1 = 10" },
            { latex: "\\frac{10.34 \\times 1.87}{5.01} \\times 2.54", answer: 9.80, trick: "\\frac{10 \\times 2}{5} \\times 2.5 = 4 \\times 2.5 = 10" },
            { latex: "\\frac{7.53 \\times 2.18}{8.04} \\times 5.13", answer: 10.47, trick: "\\frac{7.5}{8} \\times 2 \\times 5 \\approx 1 \\times 10 = 10" },
            { latex: "\\frac{1.99 \\times 8.45}{3.21} \\times 2.01", answer: 10.53, trick: "\\frac{2 \\times 8.5}{3} \\times 2 \\approx 5.7 \\times 2 = 11.4" },
            { latex: "\\frac{9.27 \\times 0.95}{4.65} \\times 7.33", answer: 13.88, trick: "\\frac{9.3}{4.65} \\times 1 \\times 7.3 \\approx 2 \\times 7.3 = 14.6" },
            { latex: "\\frac{3.72 \\times 4.15}{6.88} \\times 3.91", answer: 8.77, trick: "\\frac{4 \\times 4}{7} \\times 4 \\approx 2.3 \\times 4 = 9.2" },
            { latex: "\\frac{5.06 \\times 6.78}{2.25} \\times 1.12", answer: 17.08, trick: "\\frac{5 \\times 7}{2.25} \\times 1 \\approx 35 / 2.25 \\approx 15.5" },
            { latex: "\\frac{8.88 \\times 3.03}{9.12} \\times 4.44", answer: 13.10, trick: "\\frac{9 \\times 3}{9} \\times 4.4 = 3 \\times 4.4 = 13.2" },
            { latex: "\\frac{2.67 \\times 7.19}{4.28} \\times 6.05", answer: 27.14, trick: "\\frac{2.5 \\times 7}{4} \\times 6 \\approx 4.4 \\times 6 = 26.4" },
            { latex: "\\frac{12.1 \\times 3.9}{5.95} \\times 2.05", answer: 16.24, trick: "\\frac{12 \\times 4}{6} \\times 2 = 8 \\times 2 = 16" },
            { latex: "\\frac{1.05 \\times 14.8}{3.01} \\times 4.92", answer: 25.48, trick: "\\frac{1 \\times 15}{3} \\times 5 = 5 \\times 5 = 25" },
            { latex: "\\frac{19.8 \\times 2.51}{4.99} \\times 1.52", answer: 15.13, trick: "\\frac{20 \\times 2.5}{5} \\times 1.5 = 10 \\times 1.5 = 15" },
            { latex: "\\frac{7.8 \\times 8.2}{1.99} \\times 0.51", answer: 16.31, trick: "\\frac{8 \\times 8}{2} \\times 0.5 = 32 \\times 0.5 = 16" },
            { latex: "\\frac{9.9 \\times 10.1}{2.48} \\times 0.98", answer: 39.50, trick: "\\frac{10 \\times 10}{2.5} \\times 1 = 100 / 2.5 = 40" }
        ];

        function generateApproxOptions(correctAnswer) {
            let options = new Set([correctAnswer]);
            while (options.size < 4) {
                const offset = (Math.random() - 0.5) * 0.1; // small random difference
                const randomAnswer = parseFloat((correctAnswer * (1 + offset)).toFixed(2));
                if (randomAnswer !== correctAnswer) {
                    options.add(randomAnswer);
                }
            }
            return Array.from(options).sort(() => Math.random() - 0.5);
        }

        function startApproxGame(mode) {
            approxState.activeMode = mode;
            approxState.questions = [...approxQuestions].sort(() => Math.random() - 0.5);
            approxState.currentQIndex = 0;
            approxState.correctAnswers = 0;
            
            approxDOM.homeScreen.classList.add('hidden');
            approxDOM.gameUI.classList.remove('hidden');
            approxDOM.endScreen.classList.add('hidden');

            if (mode === 'practice') {
                approxDOM.modeDisplay.textContent = 'Practice Mode';
                approxDOM.timerLabel.style.display = 'none';
                approxDOM.timer.style.display = 'none';
                displayApproxQuestion();
            } else { // Test Mode
                approxDOM.modeDisplay.textContent = 'Test Mode';
                approxDOM.timerLabel.style.display = 'block';
                approxDOM.timer.style.display = 'block';
                startTestTimer();
                displayApproxQuestion();
            }
        }

        function displayApproxQuestion() {
            if ( (approxState.activeMode === 'test' && approxState.currentQIndex >= 20) ||
                 (approxState.activeMode === 'practice' && approxState.currentQIndex >= approxState.questions.length) ) {
                endApproxGame();
                return;
            }

            approxDOM.content.classList.remove('hidden');
            approxDOM.feedback.classList.add('hidden');
            const q = approxState.questions[approxState.currentQIndex];
            
            katex.render(q.latex, approxDOM.question, { throwOnError: false, displayMode: true });

            const options = generateApproxOptions(q.answer);
            approxDOM.options.innerHTML = '';
            options.forEach(opt => {
                const button = document.createElement('button');
                button.textContent = opt.toFixed(2);
                button.className = "approx-option w-full bg-gray-700 p-4 rounded-lg text-2xl font-bold cursor-pointer";
                button.onclick = () => selectApproxAnswer(button, opt === q.answer);
                approxDOM.options.appendChild(button);
            });
            
            approxDOM.questionCounter.textContent = `Question ${approxState.currentQIndex + 1}${approxState.activeMode === 'test' ? ' of 20' : ''}`;
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function startTestTimer() {
            approxState.timeLeft = 360; // 6 minutes
            clearInterval(approxState.timer);
            approxDOM.timer.textContent = formatTime(approxState.timeLeft);
            approxState.timer = setInterval(() => {
                approxState.timeLeft--;
                approxDOM.timer.textContent = formatTime(approxState.timeLeft);
                if (approxState.timeLeft <= 0) {
                    clearInterval(approxState.timer);
                    endApproxGame();
                }
            }, 1000);
        }

        function selectApproxAnswer(selectedButton, isCorrect) {
            if (isCorrect) approxState.correctAnswers++;

            if (approxState.activeMode === 'practice') {
                const q = approxState.questions[approxState.currentQIndex];
                approxDOM.feedbackTitle.textContent = isCorrect ? "Correct!" : "Not Quite...";
                approxDOM.feedbackTitle.className = `text-2xl font-bold mb-3 ${isCorrect ? 'text-green-400' : 'text-red-400'}`;

                Array.from(approxDOM.options.children).forEach(button => {
                    button.disabled = true;
                    if (parseFloat(button.textContent) === q.answer) button.classList.add('correct-option');
                    else if (button === selectedButton) button.classList.add('incorrect-option');
                });

                approxDOM.answerKeyTrick.textContent = q.trick;
                approxDOM.exactAnswer.textContent = q.answer.toFixed(2);
                approxDOM.content.classList.add('hidden');
                approxDOM.feedback.classList.remove('hidden');
            } else { // Test mode
                approxState.currentQIndex++;
                displayApproxQuestion();
            }
        }
        
        function endApproxGame() {
            clearInterval(approxState.timer);
            approxDOM.gameUI.classList.add('hidden');
            if (approxState.activeMode === 'test') {
                approxDOM.finalScore.textContent = `${approxState.correctAnswers} / 20`;
            } else {
                 approxDOM.finalScore.textContent = `${approxState.correctAnswers} / ${approxState.questions.length}`;
            }
            approxDOM.endScreen.classList.remove('hidden');
        }
        
        approxDOM.practiceModeBtn.addEventListener('click', () => startApproxGame('practice'));
        approxDOM.testModeBtn.addEventListener('click', () => startApproxGame('test'));
        approxDOM.nextBtn.addEventListener('click', () => {
             approxState.currentQIndex++;
             displayApproxQuestion();
        });
        approxDOM.restartBtn.addEventListener('click', () => startApproxGame(approxState.activeMode));
        approxDOM.homeBtn.addEventListener('click', showMainMenu);
        approxDOM.backToMenuBtn.addEventListener('click', showMainMenu);
        approxDOM.ingameHomeBtn.addEventListener('click', () => {
            clearInterval(approxState.timer);
            showMainMenu();
        });

        // =================================================================
        // ::: AIRPORT GEOGRAPHY LOGIC :::
        // =================================================================
        const airportDOM = {
            container: document.getElementById('airport-game-container'),
            homeScreen: document.getElementById('airport-home-screen'),
            endScreen: document.getElementById('airport-end-screen'),
            gameUI: document.getElementById('airport-game-ui'),
            modeSelectButtons: document.querySelectorAll('.mode-select-button'),
            restartButton: document.getElementById('restart-button'),
            resetProgressButton: document.getElementById('reset-progress-button'),
            backToAirportHome: document.getElementById('back-to-airport-home'),
            airportHomeFromEnd: document.getElementById('airport-home-from-end'),
            backToMainMenu: document.getElementById('back-to-main-menu-airport'),
            destinationPrompt: document.getElementById('destination-prompt'),
            questionCounter: document.getElementById('question-counter'),
            scoreCounter: document.getElementById('score-counter'),
            finalScore: document.getElementById('final-score'),
            feedbackBox: document.getElementById('airport-feedback-box'),
            feedbackText: document.getElementById('feedback-text'),
            feedbackDetails: document.getElementById('feedback-details'),
            nextButton: document.getElementById('next-button'),
            masteryDisplay: document.getElementById('mastery-display'),
            masteredCount: document.getElementById('mastered-count'),
        };
        
        const airportState = {
            map: null, score: 0, currentQuestionIndex: 0,
            shuffledDestinations: [], mapClickListener: null,
            guessMarker: null, answerMarker: null, lineToAnswer: null,
            practiceMarkers: [], destinationProgress: {},
            activeGameMode: null, progressUnsubscribe: null,
        };

        const airwaysDestinations = [
            { city: "Chiang Mai", country: "Thailand", iata: "CNX", icao: "VTCC", lat: 18.7669, lon: 98.9626 }, { city: "Chiang Rai", country: "Thailand", iata: "CEI", icao: "VTCT", lat: 19.9546, lon: 99.8828 }, { city: "Khon Kaen", country: "Thailand", iata: "KKC", icao: "VTUK", lat: 16.4673, lon: 102.7852 }, { city: "Udon Thani", country: "Thailand", iata: "UTH", icao: "VTUD", lat: 17.3871, lon: 102.8122 }, { city: "Ubon Ratchathani", country: "Thailand", iata: "UBP", icao: "VTUU", lat: 15.2508, lon: 104.8690 }, { city: "Krabi", country: "Thailand", iata: "KBV", icao: "VTSG", lat: 8.0945, lon: 98.9877 }, { city: "Hat Yai", country: "Thailand", iata: "HDY", icao: "VTSS", lat: 6.9328, lon: 100.3950 }, { city: "Phuket", country: "Thailand", iata: "HKT", icao: "VTSP", lat: 8.1132, lon: 98.3168 }, { city: "Ahmedabad", country: "India", iata: "AMD", icao: "VAAH", lat: 23.0734, lon: 72.6347 }, { city: "Beijing", country: "China", iata: "PEK", icao: "ZBAA", lat: 40.0801, lon: 116.5845 }, { city: "Bengaluru", country: "India", iata: "BLR", icao: "VOBL", lat: 13.1986, lon: 77.7063 }, { city: "Chennai", country: "India", iata: "MAA", icao: "VOMM", lat: 12.9941, lon: 80.1709 }, { city: "Chengdu", country: "China", iata: "CTU", icao: "ZUUU", lat: 30.5785, lon: 103.9485 }, { city: "Colombo", country: "Sri Lanka", iata: "CMB", icao: "VCBI", lat: 7.1802, lon: 79.8842 }, { city: "Dhaka", country: "Bangladesh", iata: "DAC", icao: "VGHS", lat: 23.8433, lon: 90.3978 }, { city: "Delhi", country: "India", iata: "DEL", icao: "VIDP", lat: 28.5562, lon: 77.1000 }, { city: "Gaya", country: "India", iata: "GAY", icao: "VEGY", lat: 24.7444, lon: 84.9511 }, { city: "Denpasar", country: "Indonesia", iata: "DPS", icao: "WADD", lat: -8.7482, lon: 115.1672 }, { city: "Fukuoka", country: "Japan", iata: "FUK", icao: "RJFF", lat: 33.5858, lon: 130.4505 }, { city: "Guangzhou", country: "China", iata: "CAN", icao: "ZGGG", lat: 23.3924, lon: 113.2988 }, { city: "Hanoi", country: "Vietnam", iata: "HAN", icao: "VVNB", lat: 21.2212, lon: 105.8072 }, { city: "Ho Chi Minh City", country: "Vietnam", iata: "SGN", icao: "VVTS", lat: 10.8222, lon: 106.6619 }, { city: "Hong Kong", country: "Hong Kong", iata: "HKG", icao: "VHHH", lat: 22.3080, lon: 113.9185 }, { city: "Hyderabad", country: "India", iata: "HYD", icao: "VOHS", lat: 17.2403, lon: 78.4294 }, { city: "Islamabad", country: "Pakistan", iata: "ISB", icao: "OPIS", lat: 33.5492, lon: 72.8256 }, { city: "Jakarta", country: "Indonesia", iata: "CGK", icao: "WIII", lat: -6.1256, lon: 106.6558 }, { city: "Karachi", country: "Pakistan", iata: "KHI", icao: "OPKC", lat: 24.9073, lon: 67.1608 }, { city: "Kathmandu", country: "Nepal", iata: "KTM", icao: "VNKT", lat: 27.6966, lon: 85.3591 }, { city: "Kaohsiung", country: "Taiwan", iata: "KHH", icao: "RCKH", lat: 22.5768, lon: 120.3499 }, { city: "Kochi", country: "India", iata: "COK", icao: "VOCI", lat: 10.1520, lon: 76.4019 }, { city: "Kolkata", country: "India", iata: "CCU", icao: "VECC", lat: 22.6547, lon: 88.4467 }, { city: "Kuala Lumpur", country: "Malaysia", iata: "KUL", icao: "WMKK", lat: 2.7456, lon: 101.7099 }, { city: "Kunming", country: "China", iata: "KMG", icao: "ZPPP", lat: 25.1019, lon: 102.928 }, { city: "Lahore", country: "Pakistan", iata: "LHE", icao: "OPLA", lat: 31.5216, lon: 74.4036 }, { city: "Manila", country: "Philippines", iata: "MNL", icao: "RPLL", lat: 14.5086, lon: 121.0194 }, { city: "Mumbai", country: "India", iata: "BOM", icao: "VABB", lat: 19.0896, lon: 72.8656 }, { city: "Nagoya", country: "Japan", iata: "NGO", icao: "RJGG", lat: 34.8584, lon: 136.8054 }, { city: "Osaka", country: "Japan", iata: "KIX", icao: "RJBB", lat: 34.4272, lon: 135.2442 }, { city: "Penang", country: "Malaysia", iata: "PEN", icao: "WMKP", lat: 5.2971, lon: 100.2766 }, { city: "Phnom Penh", country: "Cambodia", iata: "PNH", icao: "VDPP", lat: 11.5466, lon: 104.8441 }, { city: "Sapporo", country: "Japan", iata: "CTS", icao: "RJCC", lat: 42.7752, lon: 141.6923 }, { city: "Seoul", country: "South Korea", iata: "ICN", icao: "RKSI", lat: 37.4602, lon: 126.4407 }, { city: "Shanghai", country: "China", iata: "PVG", icao: "ZSPD", lat: 31.1444, lon: 121.8053 }, { city: "Siem Reap", country: "Cambodia", iata: "REP", icao: "VDSR", lat: 13.4107, lon: 103.8121 }, { city: "Singapore", country: "Singapore", iata: "SIN", icao: "WSSS", lat: 1.3644, lon: 103.9915 }, { city: "Taipei", country: "Taiwan", iata: "TPE", icao: "RCTP", lat: 25.0797, lon: 121.2345 }, { city: "Tokyo (Haneda)", country: "Japan", iata: "HND", icao: "RJTT", lat: 35.5494, lon: 139.7798 }, { city: "Tokyo (Narita)", country: "Japan", iata: "NRT", icao: "RJAA", lat: 35.7720, lon: 140.3863 }, { city: "Vientiane", country: "Laos", iata: "VTE", icao: "VLVT", lat: 17.9883, lon: 102.5633 }, { city: "Yangon", country: "Myanmar", iata: "RGN", icao: "VYYY", lat: 16.9073, lon: 96.1332 }, { city: "Brussels", country: "Belgium", iata: "BRU", icao: "EBBR", lat: 50.9014, lon: 4.4844 }, { city: "Copenhagen", country: "Denmark", iata: "CPH", icao: "EKCH", lat: 55.6180, lon: 12.6560 }, { city: "Frankfurt", country: "Germany", iata: "FRA", icao: "EDDF", lat: 50.0379, lon: 8.5622 }, { city: "Istanbul", country: "Turkey", iata: "IST", icao: "LTFM", lat: 41.2753, lon: 28.7519 }, { city: "London", country: "United Kingdom", iata: "LHR", icao: "EGLL", lat: 51.4700, lon: -0.4543 }, { city: "Melbourne", country: "Australia", iata: "MEL", icao: "YMML", lat: -37.6690, lon: 144.8410 }, { city: "Milan", country: "Italy", iata: "MXP", icao: "LIMC", lat: 45.6301, lon: 8.7285 }, { city: "Munich", country: "Germany", iata: "MUC", icao: "EDDM", lat: 48.3537, lon: 11.7861 }, { city: "Oslo", country: "Norway", iata: "OSL", icao: "ENGM", lat: 60.1976, lon: 11.1004 }, { city: "Paris", country: "France", iata: "CDG", icao: "LFPG", lat: 49.0097, lon: 2.5479 }, { city: "Perth", country: "Australia", iata: "PER", icao: "YPPH", lat: -31.9403, lon: 115.9672 }, { city: "Stockholm", country: "Sweden", iata: "ARN", icao: "ESSA", lat: 59.6498, lon: 17.9238 }, { city: "Sydney", country: "Australia", iata: "SYD", icao: "YSSY", lat: -33.9399, lon: 151.1753 }, { city: "Zurich", country: "Switzerland", iata: "ZRH", icao: "LSZH", lat: 47.4647, lon: 8.5492 }
        ];

        function loadAirportProgress(uid) {
            userId = uid;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const progressDocRef = doc(db, 'artifacts', appId, 'users', userId);

            if (airportState.progressUnsubscribe) airportState.progressUnsubscribe();
            airportState.progressUnsubscribe = onSnapshot(progressDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    airportState.destinationProgress = docSnap.data().progress || {};
                } else {
                    airwaysDestinations.forEach(dest => { airportState.destinationProgress[dest.city] = 0; });
                    saveAirportProgress();
                }
                updateProgressSummary();
            });
        }
        async function saveAirportProgress() {
            if (!userId) return;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const progressDocRef = doc(db, 'artifacts', appId, 'users', userId);
            try { await setDoc(progressDocRef, { progress: airportState.destinationProgress }, { merge: true });
            } catch (error) { console.error("Error saving progress: ", error); }
        }
        async function resetAirportProgress() {
            showConfirmModal('Reset Progress?', 'Are you sure you want to reset all airport progress?', async () => {
                airwaysDestinations.forEach(dest => { airportState.destinationProgress[dest.city] = 0; });
                await saveAirportProgress();
                airportDOM.endScreen.classList.add('hidden');
                showAirportHomeScreen();
            });
        }
        function updateProgressSummary() {
            const mastered = Object.values(airportState.destinationProgress).filter(level => level >= 3).length;
            airportDOM.masteredCount.textContent = mastered;
        }
        function getMasteryStars(city) {
            const level = airportState.destinationProgress[city] || 0;
            if (level >= 3) return '<span class="mastery-star">★★★</span>';
            if (level === 2) return '<span class="mastery-star">★★</span><span class="mastery-star-empty">☆</span>';
            if (level === 1) return '<span class="mastery-star">★</span><span class="mastery-star-empty">☆☆</span>';
            return '<span class="mastery-star-empty">☆☆☆</span>';
        }
        function initMap() {
            if (airportState.map) return;
            airportState.map = L.map('map', { center: [20, 100], zoom: 3, minZoom: 2, maxBounds: [[-90, -180], [90, 180]], worldCopyJump: true });
            L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
            }).addTo(airportState.map);
        }
        function showAirportHomeScreen() {
            airportDOM.homeScreen.classList.remove('hidden');
            airportDOM.gameUI.classList.add('hidden');
            airportDOM.endScreen.classList.add('hidden');
            airportDOM.feedbackBox.classList.add('hidden');
            clearMapLayers();
            updateProgressSummary();
        }
        function startAirportGame(mode) {
            airportState.activeGameMode = mode;
            airportDOM.homeScreen.classList.add('hidden');
            if (mode === 'practice') {
                startPracticeMode();
                return;
            }
            airportDOM.gameUI.classList.remove('hidden');
            airportState.score = 0;
            airportState.currentQuestionIndex = 0;
            updateScoreDisplay();
            airportState.shuffledDestinations = [...airwaysDestinations].sort(() => Math.random() - 0.5);
            nextAirportQuestion();
        }
        function startPracticeMode() {
            airportDOM.gameUI.classList.remove('hidden');
            airportDOM.destinationPrompt.textContent = "Practice Mode";
            airportDOM.masteryDisplay.innerHTML = "";
            airportDOM.questionCounter.textContent = "Explore";
            airportDOM.scoreCounter.textContent = "-";
            airwaysDestinations.forEach(dest => {
                const marker = L.marker([dest.lat, dest.lon], { icon: L.divIcon({ className: 'practice-marker', iconSize: [12, 12] }) }).addTo(airportState.map);
                marker.bindPopup(`<b>${dest.city}, ${dest.country}</b><br>IATA: ${dest.iata} | ICAO: ${dest.icao}<br>Mastery: ${getMasteryStars(dest.city)}`);
                airportState.practiceMarkers.push(marker);
            });
        }
        function handleMapClick(e) {
            airportState.map.off('click', airportState.mapClickListener);
            const userLatLng = e.latlng;
            const correctDestination = airportState.shuffledDestinations[airportState.currentQuestionIndex];
            const correctLatLng = L.latLng(correctDestination.lat, correctDestination.lon);
            const distance = calculateDistance(userLatLng.lat, userLatLng.lng, correctLatLng.lat, correctLatLng.lng);
            airportState.guessMarker = L.marker(userLatLng, { icon: L.divIcon({ className: 'user-guess-icon', iconSize: [12, 12] }) }).addTo(airportState.map);
            airportState.answerMarker = L.marker(correctLatLng, { icon: L.divIcon({ className: 'correct-answer-icon', iconSize: [12, 12] }) }).addTo(airportState.map).bindPopup(`<b>${correctDestination.city} (${correctDestination.iata})</b>`).openPopup();
            airportState.lineToAnswer = L.polyline([userLatLng, correctLatLng], { color: '#4f008c', weight: 2, dashArray: '5, 5' }).addTo(airportState.map);
            airportState.map.fitBounds(L.latLngBounds(userLatLng, correctLatLng), { padding: [70, 70] });
            showAirportFeedback(distance <= 150, `You were ${Math.round(distance)} km away.`);
        }
        function nextAirportQuestion() {
            clearMapLayers();
            airportDOM.feedbackBox.classList.add('hidden');
            if (airportState.currentQuestionIndex >= airportState.shuffledDestinations.length) {
                endAirportGame();
                return;
            }
            updateQuestionDisplay();
            airportState.mapClickListener = airportState.map.on('click', handleMapClick);
        }
        function showAirportFeedback(isCorrect, detailsText) {
            const correctDestination = airportState.shuffledDestinations[airportState.currentQuestionIndex];
            if (isCorrect) {
                airportState.score++;
                updateScoreDisplay();
                airportDOM.feedbackText.textContent = "Excellent! Correct!";
                airportDOM.feedbackText.className = 'text-xl font-semibold mb-4 text-green-600';
                airportState.destinationProgress[correctDestination.city] = (airportState.destinationProgress[correctDestination.city] || 0) + 1;
                saveAirportProgress();
            } else {
                airportDOM.feedbackText.textContent = `Not quite! This is ${correctDestination.city}.`;
                airportDOM.feedbackText.className = 'text-xl font-semibold mb-4 text-red-600';
            }
            airportDOM.feedbackDetails.innerHTML = `${detailsText}<br><b>${correctDestination.iata} | ${correctDestination.icao}</b>`;
            airportDOM.feedbackBox.classList.remove('hidden');
            airportState.currentQuestionIndex++;
        }
        function endAirportGame() {
            airportDOM.gameUI.classList.add('hidden');
            airportDOM.feedbackBox.classList.add('hidden');
            airportDOM.finalScore.textContent = `${airportState.score} / ${airportState.shuffledDestinations.length}`;
            airportDOM.endScreen.classList.remove('hidden');
        }
        function clearMapLayers() {
            if(!airportState.map) return;
            if (airportState.guessMarker) airportState.map.removeLayer(airportState.guessMarker);
            if (airportState.answerMarker) airportState.map.removeLayer(airportState.answerMarker);
            if (airportState.lineToAnswer) airportState.map.removeLayer(airportState.lineToAnswer);
            airportState.practiceMarkers.forEach(marker => airportState.map.removeLayer(marker));
            airportState.practiceMarkers = [];
            airportState.map.closePopup();
            airportState.guessMarker = null; airportState.answerMarker = null; airportState.lineToAnswer = null;
        }
        function updateScoreDisplay() { airportDOM.scoreCounter.textContent = airportState.score; }
        function updateQuestionDisplay() {
            const currentDestination = airportState.shuffledDestinations[airportState.currentQuestionIndex];
            airportDOM.destinationPrompt.textContent = airportState.activeGameMode === 'guessLocationName' 
                ? `${currentDestination.city}, ${currentDestination.country}` 
                : `${currentDestination.iata} / ${currentDestination.icao}`;
            airportDOM.questionCounter.textContent = `${airportState.currentQuestionIndex + 1} / ${airportState.shuffledDestinations.length}`;
            airportDOM.masteryDisplay.innerHTML = getMasteryStars(currentDestination.city);
        }
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180, dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
        }

        airportDOM.modeSelectButtons.forEach(button => button.addEventListener('click', (e) => startAirportGame(e.currentTarget.dataset.mode)));
        airportDOM.backToAirportHome.addEventListener('click', showAirportHomeScreen);
        airportDOM.airportHomeFromEnd.addEventListener('click', showAirportHomeScreen);
        airportDOM.nextButton.addEventListener('click', nextAirportQuestion);
        airportDOM.restartButton.addEventListener('click', () => {
            airportDOM.endScreen.classList.add('hidden');
            startAirportGame(airportState.activeGameMode);
        });
        airportDOM.resetProgressButton.addEventListener('click', resetAirportProgress);
        airportDOM.backToMainMenu.addEventListener('click', showMainMenu);

        // =================================================================
        // ::: GENERAL APP LOGIC :::
        // =================================================================
        function showMainMenu() {
            homeScreen.classList.remove('hidden');
            airportGameContainer.classList.add('hidden');
            approxGameContainer.classList.add('hidden');
            cubeGameContainer.classList.add('hidden');
        }
        
        function showConfirmModal(title, text, onConfirm) {
            document.getElementById('confirm-title').textContent = title;
            document.getElementById('confirm-text').textContent = text;
            onConfirmAction = onConfirm;
            confirmModal.classList.remove('hidden');
        }
        
        selectAirportGame.addEventListener('click', () => {
            homeScreen.classList.add('hidden');
            airportGameContainer.classList.remove('hidden');
            showAirportHomeScreen();
        });

        selectApproxGame.addEventListener('click', () => {
            homeScreen.classList.add('hidden');
            approxGameContainer.classList.remove('hidden');
            approxDOM.homeScreen.classList.remove('hidden');
            approxDOM.gameUI.classList.add('hidden');
        });

        selectCubeGame.addEventListener('click', () => {
            homeScreen.classList.add('hidden');
            cubeGameContainer.classList.remove('hidden');
            showCubeHomeScreen();
        });

        // =================================================================
        // ::: 3D CUBE PUZZLE LOGIC :::
        // =================================================================
        const cubeDOM = {
            homeScreen: document.getElementById('cube-home-screen'),
            gameUI: document.getElementById('cube-game-ui'),
            standardModeBtn: document.getElementById('cube-standard-mode-btn'),
            challengeModeBtn: document.getElementById('cube-challenge-mode-btn'),
            backToMenuFromHomeBtn: document.getElementById('cube-back-to-main-menu-from-home'),
            backToHomeBtn: document.getElementById('cube-back-to-home'),
            problemCounter: document.getElementById('cube-problem-counter'),
            timer: document.getElementById('cube-timer'),
            choicesContainer: document.getElementById('cube-choices-container'),
            prevBtn: document.getElementById('cube-prev-btn'),
            nextBtn: document.getElementById('cube-next-btn'),
            endScreen: document.getElementById('cube-end-screen'),
            finalScore: document.getElementById('cube-final-score'),
            answerKeyContainer: document.getElementById('answer-key-container'),
            restartBtn: document.getElementById('cube-restart-btn'),
            endHomeBtn: document.getElementById('cube-end-home-btn'),
        };
        
        const cubeState = {
            problemSet: [],
            userAnswers: [],
            currentProblemIndex: 0,
            activeMode: 'standard',
            renderers: [],
            timer: null,
            timeLeft: 420, // 7 minutes
            colors: { part1: '#FFFFFF', part2: '#E53935', choice: '#4CAF50' }
        };

        function showCubeHomeScreen() {
            cubeDOM.homeScreen.classList.remove('hidden');
            cubeDOM.gameUI.classList.add('hidden');
            cubeDOM.endScreen.classList.add('hidden');
            clearInterval(cubeState.timer);
            cubeState.renderers.forEach(r => r.stop());
        }

        function startCubeGame(mode) {
            cubeState.activeMode = mode;
            cubeDOM.homeScreen.classList.add('hidden');
            cubeDOM.gameUI.classList.remove('hidden');
            cubeDOM.endScreen.classList.add('hidden');
            
            if(mode === 'challenge') cubeDOM.gameUI.classList.add('challenge-mode');
            else cubeDOM.gameUI.classList.remove('challenge-mode');

            cubeState.currentProblemIndex = 0;
            generateProblemSet();
            cubeState.userAnswers = Array(15).fill(null);
            displayCubeProblem();
            startCubeTimer();
        }

        function generateProblemSet() {
            cubeState.problemSet = [];
            for (let i = 0; i < 15; i++) {
                const allPositions = [];
                for (let x=0; x<3; x++) for (let y=0; y<3; y++) for (let z=0; z<3; z++) allPositions.push({x,y,z});
                allPositions.sort(() => Math.random() - 0.5);
                const part1 = allPositions.slice(0, 9);
                const part2 = allPositions.slice(9, 18);
                const correctPart = allPositions.slice(18, 27);
                const distractors = [];
                while (distractors.length < 3) {
                    const d = [...allPositions].sort(() => Math.random() - 0.5).slice(0, 9);
                    if (JSON.stringify(d) !== JSON.stringify(correctPart)) distractors.push(d);
                }
                const choices = [correctPart, ...distractors].sort(() => Math.random() - 0.5);
                const correctChoiceIndex = choices.findIndex(c => JSON.stringify(c) === JSON.stringify(correctPart));
                cubeState.problemSet.push({ part1, part2, choices, correctChoiceIndex });
            }
        }

        function displayCubeProblem() {
            cubeState.renderers.forEach(r => r.stop());
            cubeState.renderers = [];
            
            const problem = cubeState.problemSet[cubeState.currentProblemIndex];
            cubeDOM.problemCounter.textContent = `Problem ${cubeState.currentProblemIndex + 1} / 15`;
            const options = { mode: cubeState.activeMode };

            cubeState.renderers.push(new CanvasRenderer('cube-viewer-part1', problem.part1, cubeState.colors.part1, options));
            cubeState.renderers.push(new CanvasRenderer('cube-viewer-part2', problem.part2, cubeState.colors.part2, options));
            
            cubeDOM.choicesContainer.innerHTML = '';
            problem.choices.forEach((choice, index) => {
                const card = document.createElement('div');
                card.className = 'cube-choice-card bg-gray-800 border-2 border-gray-700 rounded-lg p-2 cursor-pointer';
                if (cubeState.userAnswers[cubeState.currentProblemIndex] === index) {
                    card.classList.add('selected-choice');
                }
                const canvasId = `cube-choice-viewer-${index}`;
                card.innerHTML = `<h3 class="text-center font-bold mb-2">Choice ${String.fromCharCode(65 + index)}</h3><canvas id="${canvasId}" class="w-full h-auto aspect-square rounded-md bg-gray-900"></canvas>`;
                card.addEventListener('click', () => handleCubeChoice(index));
                cubeDOM.choicesContainer.appendChild(card);
                cubeState.renderers.push(new CanvasRenderer(canvasId, choice, cubeState.colors.choice, options));
            });
            updateNavButtons();
        }

        function handleCubeChoice(choiceIndex) {
            cubeState.userAnswers[cubeState.currentProblemIndex] = choiceIndex;
            Array.from(cubeDOM.choicesContainer.children).forEach((card, index) => {
                card.classList.toggle('selected-choice', index === choiceIndex);
            });
        }
        
        function updateNavButtons() {
            cubeDOM.prevBtn.disabled = cubeState.currentProblemIndex === 0;
            if (cubeState.currentProblemIndex === 14) {
                cubeDOM.nextBtn.textContent = 'Submit';
                cubeDOM.nextBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                cubeDOM.nextBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            } else {
                cubeDOM.nextBtn.textContent = 'Next';
                cubeDOM.nextBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                cubeDOM.nextBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            }
        }
        
        function navigateProblems(direction) {
            const newIndex = cubeState.currentProblemIndex + direction;
            if (newIndex >= 0 && newIndex < 15) {
                cubeState.currentProblemIndex = newIndex;
                displayCubeProblem();
            }
        }

        function startCubeTimer() {
            clearInterval(cubeState.timer);
            cubeState.timeLeft = 420;
            cubeDOM.timer.textContent = formatTime(cubeState.timeLeft);
            cubeState.timer = setInterval(() => {
                cubeState.timeLeft--;
                cubeDOM.timer.textContent = formatTime(cubeState.timeLeft);
                if (cubeState.timeLeft <= 0) {
                    endCubeGame();
                }
            }, 1000);
        }

        function endCubeGame() {
            clearInterval(cubeState.timer);
            cubeState.renderers.forEach(r => r.stop());
            cubeState.renderers = [];
            let score = 0;
            cubeState.userAnswers.forEach((answer, index) => {
                if (answer === cubeState.problemSet[index].correctChoiceIndex) {
                    score++;
                }
            });
            cubeDOM.finalScore.textContent = `${score} / 15`;
            generateAnswerKey();
            cubeDOM.gameUI.classList.add('hidden');
            cubeDOM.endScreen.classList.remove('hidden');
        }

        function generateAnswerKey() {
            cubeDOM.answerKeyContainer.innerHTML = '';
            cubeState.problemSet.forEach((problem, index) => {
                const userAnswerIndex = cubeState.userAnswers[index];
                const isCorrect = userAnswerIndex === problem.correctChoiceIndex;
                const userAnswerLetter = userAnswerIndex !== null ? String.fromCharCode(65 + userAnswerIndex) : 'None';
                const correctAnswerLetter = String.fromCharCode(65 + problem.correctChoiceIndex);

                const resultDiv = document.createElement('div');
                resultDiv.className = 'p-3 border-b border-gray-700';
                resultDiv.innerHTML = `
                    <div class="flex items-center justify-between">
                        <p class="font-bold text-lg">Problem ${index + 1}: 
                            <span class="${isCorrect ? 'text-green-400' : 'text-red-400'}">${isCorrect ? 'Correct' : 'Incorrect'}</span>
                        </p>
                        <button data-key-index="${index}" class="show-answer-btn bg-gray-600 hover:bg-gray-500 text-sm py-1 px-3 rounded-md">Show Answer</button>
                    </div>
                    <p class="text-sm text-gray-400">You chose: ${userAnswerLetter} | Correct: ${correctAnswerLetter}</p>
                    <div id="answer-key-viewer-${index}" class="hidden mt-4">
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 p-2 bg-gray-800 rounded-lg">
                            <div>
                                <h4 class="text-center font-bold text-xs mb-1">Problem Part 1</h4>
                                <canvas id="ak-part1-canvas-${index}" class="w-full aspect-square bg-gray-900 rounded-md"></canvas>
                            </div>
                            <div>
                                <h4 class="text-center font-bold text-xs mb-1">Problem Part 2</h4>
                                <canvas id="ak-part2-canvas-${index}" class="w-full aspect-square bg-gray-900 rounded-md"></canvas>
                            </div>
                            <div>
                                <h4 class="text-center font-bold text-xs mb-1">Solid Assembly</h4>
                                <canvas id="ak-solid-canvas-${index}" class="w-full aspect-square bg-gray-900 rounded-md"></canvas>
                            </div>
                            <div>
                                <h4 class="text-center font-bold text-xs mb-1">Gapped Assembly</h4>
                                <canvas id="ak-gapped-canvas-${index}" class="w-full aspect-square bg-gray-900 rounded-md"></canvas>
                            </div>
                        </div>
                         <div class="p-2 bg-gray-800 rounded-lg mt-4">
                            <h4 class="text-center font-bold text-xs mb-1">2D Layers</h4>
                            <canvas id="ak-layers-canvas-${index}" class="w-full max-w-sm mx-auto aspect-[2/1] bg-gray-900 rounded-md"></canvas>
                        </div>
                    </div>
                `;
                cubeDOM.answerKeyContainer.appendChild(resultDiv);
            });

            document.querySelectorAll('.show-answer-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = e.target.dataset.keyIndex;
                    const viewer = document.getElementById(`answer-key-viewer-${index}`);
                    const isHidden = viewer.classList.toggle('hidden');
                    e.target.textContent = isHidden ? 'Show Answer' : 'Hide Answer';

                    if (!isHidden && !e.target.dataset.rendered) {
                        const problem = cubeState.problemSet[index];
                        const correctPart = problem.choices[problem.correctChoiceIndex];
                        const fullCubeParts = { part1: problem.part1, part2: problem.part2, choice: correctPart };
                        
                        const problemOptions = { mode: cubeState.activeMode };
                        const solutionOptions = { mode: 'standard' }; 
                        
                        new CanvasRenderer(`ak-part1-canvas-${index}`, problem.part1, cubeState.colors.part1, problemOptions);
                        new CanvasRenderer(`ak-part2-canvas-${index}`, problem.part2, cubeState.colors.part2, problemOptions);
                        new CanvasRenderer(`ak-solid-canvas-${index}`, fullCubeParts, null, { ...solutionOptions, isAssembled: true, isGapped: false });
                        new CanvasRenderer(`ak-gapped-canvas-${index}`, fullCubeParts, null, { ...solutionOptions, isAssembled: true, isGapped: true });
                        draw2DLayers(`ak-layers-canvas-${index}`, fullCubeParts, cubeState.colors);

                        e.target.dataset.rendered = 'true';
                    }
                });
            });
        }

        function draw2DLayers(canvasId, fullCubeParts, colors) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            canvas.width = 300; canvas.height = 150;
            const ctx = canvas.getContext('2d');
            const part1Set = new Set(fullCubeParts.part1.map(p => `${p.x},${p.y},${p.z}`));
            const part2Set = new Set(fullCubeParts.part2.map(p => `${p.x},${p.y},${p.z}`));
            const choiceSet = new Set(fullCubeParts.choice.map(p => `${p.x},${p.y},${p.z}`));
            const gridSpacing = 10; const gridWidth = (canvas.width - gridSpacing * 2) / 3;
            const cellWidth = gridWidth / 3; const startY = 30;
            const layerTitles = ["Bottom", "Middle", "Top"];
            
            for (let z = 0; z < 3; z++) {
                const startX = z * (gridWidth + gridSpacing);
                ctx.fillStyle = '#FFFFFF'; ctx.font = `12px Inter`;
                ctx.textAlign = 'center';
                ctx.fillText(layerTitles[z], startX + gridWidth / 2, startY - 10);
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        const coord = `${x},${y},${z}`;
                        let color = '#374151';
                        if (part1Set.has(coord)) color = colors.part1;
                        else if (part2Set.has(coord)) color = colors.part2;
                        else if (choiceSet.has(coord)) color = colors.choice;
                        ctx.fillStyle = color;
                        ctx.fillRect(startX + x * cellWidth, startY + (2 - y) * cellWidth, cellWidth, cellWidth);
                        ctx.strokeStyle = '#111827'; ctx.lineWidth = 1;
                        ctx.strokeRect(startX + x * cellWidth, startY + (2 - y) * cellWidth, cellWidth, cellWidth);
                    }
                }
            }
        }
        
        cubeDOM.standardModeBtn.addEventListener('click', () => startCubeGame('standard'));
        cubeDOM.challengeModeBtn.addEventListener('click', () => startCubeGame('challenge'));
        cubeDOM.prevBtn.addEventListener('click', () => navigateProblems(-1));
        cubeDOM.nextBtn.addEventListener('click', () => {
            if (cubeState.currentProblemIndex === 14) endCubeGame();
            else navigateProblems(1);
        });
        cubeDOM.restartBtn.addEventListener('click', () => startCubeGame(cubeState.activeMode));
        cubeDOM.endHomeBtn.addEventListener('click', showCubeHomeScreen);
        cubeDOM.backToHomeBtn.addEventListener('click', showCubeHomeScreen);
        cubeDOM.backToMenuFromHomeBtn.addEventListener('click', showMainMenu);

        class CanvasRenderer {
            constructor(canvasId, data, primaryColor, options = {}) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.options = { mode: 'standard', ...options };
                this.partsToRender = []; this.animationFrameId = null;
                this.isDragging = false;
                this.lastMouseX = 0; this.lastMouseY = 0;
                this.vertices = [ {x:-0.5,y:-0.5,z:-0.5},{x:0.5,y:-0.5,z:-0.5},{x:0.5,y:0.5,z:-0.5},{x:-0.5,y:0.5,z:-0.5}, {x:-0.5,y:-0.5,z:0.5},{x:0.5,y:-0.5,z:0.5},{x:0.5,y:0.5,z:0.5},{x:-0.5,y:0.5,z:0.5} ];
                this.faces = [ [0,1,2,3],[1,5,6,2],[5,4,7,6],[4,0,3,7],[3,2,6,7],[4,5,1,0] ];
                
                this.angleX = 0.5; this.angleY = -0.5;
                if(this.options.mode === 'challenge') {
                    const challengeAngles = [
                        { x: 0.2, y: -0.3 }, { x: -0.4, y: 0.6 }, { x: 0.6, y: 0.8 },
                        { x: -0.5, y: -0.5 }, { x: 0.3, y: 0.9 }, { x: 0.7, y: -0.1 }
                    ];
                    const randomAngle = challengeAngles[Math.floor(Math.random() * challengeAngles.length)];
                    this.angleX = randomAngle.x;
                    this.angleY = randomAngle.y;
                }

                if (this.options.isAssembled) {
                    for (const key in data) {
                        data[key].forEach(pos => this.partsToRender.push({ ...pos, color: cubeState.colors[key] }));
                    }
                } else {
                    data.forEach(pos => this.partsToRender.push({ ...pos, color: primaryColor }));
                }

                this.setCanvasSize(); this.setupMouseControls();
                window.addEventListener('resize', () => this.setCanvasSize(), false);
            }
            setCanvasSize() {
                if (!this.canvas.clientWidth) return;
                this.canvas.width = this.canvas.clientWidth; this.canvas.height = this.canvas.clientHeight;
                if (this.options.isGapped) this.cubeScale = this.canvas.width * 0.16;
                else if (this.options.isAssembled) this.cubeScale = this.canvas.width * 0.22;
                else this.cubeScale = this.canvas.width * 0.2;
                this.draw();
            }
            project(p) {
                const rY = { x: Math.cos(this.angleY)*p.x + Math.sin(this.angleY)*p.z, y: p.y, z: -Math.sin(this.angleY)*p.x + Math.cos(this.angleY)*p.z };
                const rXY = { x: rY.x, y: Math.cos(this.angleX)*rY.y - Math.sin(this.angleX)*rY.z, z: Math.sin(this.angleX)*rY.y + Math.cos(this.angleX)*rY.z };
                return { x: rXY.x * this.cubeScale, y: rXY.y * this.cubeScale, z: rXY.z };
            }
            draw() {
                if (!this.ctx) return; this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save(); this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                const allFaces = [];
                const gap = this.options.isGapped ? 1.6 : (this.options.isAssembled ? 1.0 : 1.2);

                this.partsToRender.forEach(part => {
                    const offset = {x:(part.x-1)*gap, y:(part.y-1)*gap, z:(part.z-1)*gap};
                    const pVerts = this.vertices.map(v => this.project({x:v.x+offset.x, y:v.y+offset.y, z:v.z+offset.z}));
                    this.faces.forEach(f => {
                        const fPoints = f.map(i => pVerts[i]);
                        allFaces.push({ points: fPoints, z: fPoints.reduce((s,p)=>s+p.z,0)/4, color: part.color });
                    });
                });

                allFaces.sort((a, b) => a.z - b.z);
                allFaces.forEach(face => {
                    this.ctx.beginPath(); this.ctx.moveTo(face.points[0].x, face.points[0].y);
                    for (let i=1; i<face.points.length; i++) this.ctx.lineTo(face.points[i].x, face.points[i].y);
                    this.ctx.closePath(); this.ctx.fillStyle=face.color; this.ctx.strokeStyle='#111827';
                    this.ctx.lineWidth=2; this.ctx.fill(); this.ctx.stroke();
                });
                this.ctx.restore();
            }
            stop() { if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId); }
            setupMouseControls() {
                if (this.options.mode === 'challenge') {
                    this.canvas.style.cursor = 'default';
                    return;
                }
                const start = (x, y) => { this.isDragging = true; this.lastMouseX = x; this.lastMouseY = y; };
                const drag = (x, y) => { if (this.isDragging) {
                    this.angleY += (x - this.lastMouseX) * 0.01; this.angleX += (y - this.lastMouseY) * 0.01;
                    this.lastMouseX = x; this.lastMouseY = y; this.draw();
                }};
                const end = () => { this.isDragging = false; };
                this.canvas.addEventListener('mousedown', e => start(e.clientX, e.clientY));
                this.canvas.addEventListener('mousemove', e => drag(e.clientX, e.clientY));
                this.canvas.addEventListener('mouseup', end); this.canvas.addEventListener('mouseleave', end);
                this.canvas.addEventListener('touchstart', e=>{e.preventDefault();start(e.touches[0].clientX,e.touches[0].clientY);});
                this.canvas.addEventListener('touchmove', e=>{e.preventDefault();drag(e.touches[0].clientX,e.touches[0].clientY);});
                this.canvas.addEventListener('touchend', e=>{e.preventDefault();end();});
            }
        }
        
        // --- App Initialization ---
        window.onload = () => {
            initMap();
            
            // Dummy Firebase config for offline development.
            // Replace with your actual config if deploying.
            const firebaseConfig = {
                  apiKey: "AIzaSyD4v0iN7y1C9GEDYhgyxv2koaJCUxjtnqg",
                  authDomain: "airport-qui.firebaseapp.com",
                  projectId: "airport-qui",
                  storageBucket: "airport-qui.firebasestorage.app",
                  messagingSenderId: "66527997631",
                  appId: "1:66527997631:web:942a882fb564ac8e78600a",
                  measurementId: "G-J8QFJLJWMP"
            };

            if (!firebaseConfig || !firebaseConfig.projectId || firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.warn("Using offline mode. Progress will not be saved.");
                loadingScreen.classList.add('hidden');
                showMainMenu();
                isInitialLoad = false;
                userIdDisplay.textContent = 'offline-user';
                airwaysDestinations.forEach(dest => { airportState.destinationProgress[dest.city] = 0; });
                updateProgressSummary();
                return;
            }
            
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userIdDisplay.textContent = user.uid;
                    loadAirportProgress(user.uid);
                    if (isInitialLoad) {
                        loadingScreen.classList.add('hidden');
                        showMainMenu();
                        isInitialLoad = false;
                    }
                } else {
                    try { await signInAnonymously(auth); } 
                    catch (error) {
                        console.error("Authentication failed: ", error);
                        loadingScreen.innerHTML = "<h1>Authentication Failed</h1>";
                    }
                }
            });

            confirmNoButton.addEventListener('click', () => {
                confirmModal.classList.add('hidden');
                onConfirmAction = null;
            });
            confirmYesButton.addEventListener('click', () => {
                if (onConfirmAction) onConfirmAction();
                confirmModal.classList.add('hidden');
                onConfirmAction = null;
            });
        };
    </script>
</body>
</html>

